# 1625. Lexicographically Smallest String After Applying Operations

**Difficulty:** Medium

## Problem Description

You are given a string s of even length consisting of digits from 0 to 9, and two integers a and b.

You can apply either of the following two operations any number of times and in any order on s:

1. **Add a to all odd indices of s (0-indexed)**: Digits post 9 are cycled back to 0. For example, if s = "3456" and a = 5, s becomes "3951".
2. **Rotate s to the right by b positions**: For example, if s = "3456" and b = 1, s becomes "6345".

Return the lexicographically smallest string you can obtain by applying the above operations any number of times on s.

A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, "0158" is lexicographically smaller than "0190" because the first position they differ is at the third letter, and '5' comes before '9'.

## Examples

### Example 1:
```
Input: s = "5525", a = 9, b = 2
Output: "2050"
Explanation: We can apply the following operations:
Start:  "5525"
Rotate: "2555"
Add:    "2454"
Add:    "2353"
Rotate: "5323"
Add:    "5222"
Add:    "5121"
Rotate: "2151"
Add:    "2050"
There is no way to obtain a string that is lexicographically smaller than "2050".
```

### Example 2:
```
Input: s = "74", a = 5, b = 1
Output: "24"
Explanation: We can apply the following operations:
Start:  "74"
Rotate: "47"
Add:    "42"
Rotate: "24"
There is no way to obtain a string that is lexicographically smaller than "24".
```

### Example 3:
```
Input: s = "0011", a = 4, b = 2
Output: "0011"
Explanation: There are no sequence of operations that will give us a lexicographically smaller string than "0011".
```

## Constraints

- 2 <= s.length <= 100
- s.length is even.
- s consists of digits from 0 to 9 only.
- 1 <= a <= 9
- 1 <= b <= s.length - 1

## Approach

This problem can be solved using Depth-First Search (DFS) to explore all possible string states:

1. **State Space Exploration**: Use DFS to explore all possible strings that can be generated by applying operations.
2. **Operation Implementation**: 
   - Add operation: Increment odd-indexed digits by 'a' with modulo 10
   - Rotate operation: Right-rotate string by 'b' positions
3. **Cycle Detection**: Use a set to track visited states and avoid infinite loops.
4. **Result Selection**: Return the lexicographically smallest string found.

## Algorithm

1. Create helper functions for both operations:
   - `addOdd()`: Increment odd-indexed digits by 'a' (mod 10)
   - `rotate()`: Right-rotate string by 'b' positions
2. Use DFS to explore all possible states:
   - Start with the original string
   - Apply both operations recursively
   - Track visited states to avoid cycles
3. Return the minimum string from all explored states

## Key Optimizations

- **Increment Map**: Pre-compute digit increments for O(1) lookup
- **Visited Set**: Prevent revisiting the same string states
- **Early Termination**: DFS naturally explores all reachable states

## Time Complexity

- **Time**: O(10^n) in the worst case where n is the string length
  - Each digit can cycle through 10 values
  - DFS explores all possible combinations
- **Space**: O(10^n) for the visited set and recursion stack

## Solution

The solution uses DFS to explore all possible string states:
- Implements both operations (add to odd indices, rotate)
- Uses a visited set to prevent infinite loops
- Returns the lexicographically smallest string found
- Handles digit cycling with modulo 10 arithmetic
